"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from toan_fndtn import errors, models, utils
from toan_fndtn._hooks import HookContext
from toan_fndtn.types import OptionalNullable, UNSET
from toan_fndtn.utils import get_security_from_env
from toan_fndtn.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Dict, List, Mapping, Optional, Union


class DataProduct(BaseSDK):
    def get_entities_api_data_data_product_list_get(
        self,
        *,
        x_org: str,
        has_child: OptionalNullable[bool] = UNSET,
        has_parent: OptionalNullable[bool] = UNSET,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductEntityList:
        r"""Get list of element 'data_product'

        Get data products.

        Args:
        ----
        context: Request context
        has_child: Filter by child.
        has_parent: Filter by parent.
        browse_filter: Browse filter.
        token: Token data.

        Returns:
        --------
        schema.common.EntityList: List of data products.

        :param x_org:
        :param has_child:
        :param has_parent:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntitiesAPIDataDataProductListGetRequest(
            has_child=has_child,
            has_parent=has_parent,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entities_api_data_data_product_list_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductEntityList, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_entities_api_data_data_product_list_get_async(
        self,
        *,
        x_org: str,
        has_child: OptionalNullable[bool] = UNSET,
        has_parent: OptionalNullable[bool] = UNSET,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductEntityList:
        r"""Get list of element 'data_product'

        Get data products.

        Args:
        ----
        context: Request context
        has_child: Filter by child.
        has_parent: Filter by parent.
        browse_filter: Browse filter.
        token: Token data.

        Returns:
        --------
        schema.common.EntityList: List of data products.

        :param x_org:
        :param has_child:
        :param has_parent:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntitiesAPIDataDataProductListGetRequest(
            has_child=has_child,
            has_parent=has_parent,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/list",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entities_api_data_data_product_list_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductEntityList, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_queryable_entities_api_data_data_product_list_query_get(
        self,
        *,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductEntityList:
        r"""Get list of element 'data_product' that user can query

        Get data products that can be consumed.

        Args:
        ----
        context: Request context
        browse_filter: Browse filter.
        token: Token data.

        Returns:
        --------
        schema.common.EntityList: List of data products.

        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetQueryableEntitiesAPIDataDataProductListQueryGetRequest(
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/list/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_queryable_entities_api_data_data_product_list_query_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductEntityList, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_queryable_entities_api_data_data_product_list_query_get_async(
        self,
        *,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductEntityList:
        r"""Get list of element 'data_product' that user can query

        Get data products that can be consumed.

        Args:
        ----
        context: Request context
        browse_filter: Browse filter.
        token: Token data.

        Returns:
        --------
        schema.common.EntityList: List of data products.

        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetQueryableEntitiesAPIDataDataProductListQueryGetRequest(
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/list/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_queryable_entities_api_data_data_product_list_query_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductEntityList, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_data_product_consumers_api_data_data_product_consumers_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductConsumersResponse:
        r"""Get users that can consume given 'data_product'

        Get users allowed to consume data product.

        Args:
        -----
        identifier: Product identifier.
        context: Request context
        request: fastapi.Request
        token: Token data.
        user_filter: BrowseFilter
        access_validator: AccessValidator

        Returns:
        --------
        schema.data_product.ProductConsumersResponse: List of users that can consume data products that user is allowed to see.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductConsumersAPIDataDataProductConsumersGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/consumers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_consumers_api_data_data_product_consumers_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DataProductConsumersResponse, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_data_product_consumers_api_data_data_product_consumers_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductConsumersResponse:
        r"""Get users that can consume given 'data_product'

        Get users allowed to consume data product.

        Args:
        -----
        identifier: Product identifier.
        context: Request context
        request: fastapi.Request
        token: Token data.
        user_filter: BrowseFilter
        access_validator: AccessValidator

        Returns:
        --------
        schema.data_product.ProductConsumersResponse: List of users that can consume data products that user is allowed to see.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductConsumersAPIDataDataProductConsumersGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/consumers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_consumers_api_data_data_product_consumers_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DataProductConsumersResponse, http_res
            )
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_entity_api_data_data_product_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductResponse:
        r"""Get specific element 'data_product' by identifier

        Get data product.
        ∂f
        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_product.ProductResponse: Product.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityAPIDataDataProductGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_api_data_data_product_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_entity_api_data_data_product_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductResponse:
        r"""Get specific element 'data_product' by identifier

        Get data product.
        ∂f
        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_product.ProductResponse: Product.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityAPIDataDataProductGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_api_data_data_product_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_entity_api_data_data_product_put(
        self,
        *,
        identifier: str,
        x_org: str,
        entity: Union[
            models.BackendDataSchemaCommonCreateEntity,
            models.BackendDataSchemaCommonCreateEntityTypedDict,
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Entity:
        r"""Update specific element 'data_product' by identifier

        Update data product.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product data.
        token: Token data.

        Returns:
        --------
        schema.common.Entity: Updated entity.

        :param identifier:
        :param x_org:
        :param entity: Create entity.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateEntityAPIDataDataProductPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_entity_request=models.UpdateEntityRequest(
                entity=utils.get_pydantic_model(
                    entity, models.BackendDataSchemaCommonCreateEntity
                ),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_entity_request,
                False,
                False,
                "json",
                models.UpdateEntityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_entity_api_data_data_product_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Entity, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_entity_api_data_data_product_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        entity: Union[
            models.BackendDataSchemaCommonCreateEntity,
            models.BackendDataSchemaCommonCreateEntityTypedDict,
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Entity:
        r"""Update specific element 'data_product' by identifier

        Update data product.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product data.
        token: Token data.

        Returns:
        --------
        schema.common.Entity: Updated entity.

        :param identifier:
        :param x_org:
        :param entity: Create entity.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateEntityAPIDataDataProductPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_entity_request=models.UpdateEntityRequest(
                entity=utils.get_pydantic_model(
                    entity, models.BackendDataSchemaCommonCreateEntity
                ),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_entity_request,
                False,
                False,
                "json",
                models.UpdateEntityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_entity_api_data_data_product_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Entity, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def create_entity_api_data_data_product_post(
        self,
        *,
        x_org: str,
        entity: Union[
            models.BackendDataSchemaCommonCreateEntity,
            models.BackendDataSchemaCommonCreateEntityTypedDict,
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        entity_info: OptionalNullable[
            Union[models.EntityInfo, models.EntityInfoTypedDict]
        ] = UNSET,
        parent: OptionalNullable[
            Union[models.EntityParent, models.EntityParentTypedDict]
        ] = UNSET,
        host_mesh_identifier: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityResponse:
        r"""Create a new 'data_product' element.

        Create data product.

        Args:
        ----
        context: Request context
        emitter: Product event emitter.
        data: Product data.
        token: Token data.

        Returns:
        --------
        schema.common.Entity: Created entity.

        :param x_org:
        :param entity: Create entity.
        :param x_org_override:
        :param entity_info:
        :param parent:
        :param host_mesh_identifier:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateEntityAPIDataDataProductPostRequest(
            x_org=x_org,
            x_org_override=x_org_override,
            create_data_product_request=models.CreateDataProductRequest(
                entity=utils.get_pydantic_model(
                    entity, models.BackendDataSchemaCommonCreateEntity
                ),
                entity_info=utils.get_pydantic_model(
                    entity_info, OptionalNullable[models.EntityInfo]
                ),
                parent=utils.get_pydantic_model(
                    parent, OptionalNullable[models.EntityParent]
                ),
                host_mesh_identifier=host_mesh_identifier,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_data_product_request,
                False,
                False,
                "json",
                models.CreateDataProductRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="create_entity_api_data_data_product_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def create_entity_api_data_data_product_post_async(
        self,
        *,
        x_org: str,
        entity: Union[
            models.BackendDataSchemaCommonCreateEntity,
            models.BackendDataSchemaCommonCreateEntityTypedDict,
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        entity_info: OptionalNullable[
            Union[models.EntityInfo, models.EntityInfoTypedDict]
        ] = UNSET,
        parent: OptionalNullable[
            Union[models.EntityParent, models.EntityParentTypedDict]
        ] = UNSET,
        host_mesh_identifier: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityResponse:
        r"""Create a new 'data_product' element.

        Create data product.

        Args:
        ----
        context: Request context
        emitter: Product event emitter.
        data: Product data.
        token: Token data.

        Returns:
        --------
        schema.common.Entity: Created entity.

        :param x_org:
        :param entity: Create entity.
        :param x_org_override:
        :param entity_info:
        :param parent:
        :param host_mesh_identifier:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CreateEntityAPIDataDataProductPostRequest(
            x_org=x_org,
            x_org_override=x_org_override,
            create_data_product_request=models.CreateDataProductRequest(
                entity=utils.get_pydantic_model(
                    entity, models.BackendDataSchemaCommonCreateEntity
                ),
                entity_info=utils.get_pydantic_model(
                    entity_info, OptionalNullable[models.EntityInfo]
                ),
                parent=utils.get_pydantic_model(
                    parent, OptionalNullable[models.EntityParent]
                ),
                host_mesh_identifier=host_mesh_identifier,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.create_data_product_request,
                False,
                False,
                "json",
                models.CreateDataProductRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="create_entity_api_data_data_product_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def delete_entity_api_data_data_product_delete(
        self,
        *,
        identifier: str,
        x_org: str,
        force: Optional[bool] = False,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Delete specific element 'data_product' by identifier

        Delete data product.

        Args:
        -----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        force: Force delete.
        token: Token data.
        trino: Trino client.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param force:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteEntityAPIDataDataProductDeleteRequest(
            identifier=identifier,
            force=force,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_entity_api_data_data_product_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def delete_entity_api_data_data_product_delete_async(
        self,
        *,
        identifier: str,
        x_org: str,
        force: Optional[bool] = False,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Delete specific element 'data_product' by identifier

        Delete data product.

        Args:
        -----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        force: Force delete.
        token: Token data.
        trino: Trino client.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param force:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteEntityAPIDataDataProductDeleteRequest(
            identifier=identifier,
            force=force,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_entity_api_data_data_product_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_data_product_host_mesh_api_data_data_product_patch(
        self,
        *,
        identifier: str,
        x_org: str,
        mesh_identifier: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Update data product host mesh

        Update data product host mesh.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        token: Token data.
        request: Update request.

        Returns:
        --------
        None

        :param identifier:
        :param x_org:
        :param mesh_identifier:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateDataProductHostMeshAPIDataDataProductPatchRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            data_product_mesh_availability_request=models.DataProductMeshAvailabilityRequest(
                mesh_identifier=mesh_identifier,
            ),
        )

        req = self._build_request(
            method="PATCH",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.data_product_mesh_availability_request,
                False,
                False,
                "json",
                models.DataProductMeshAvailabilityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_data_product_host_mesh_api_data_data_product_patch",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_data_product_host_mesh_api_data_data_product_patch_async(
        self,
        *,
        identifier: str,
        x_org: str,
        mesh_identifier: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Update data product host mesh

        Update data product host mesh.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        token: Token data.
        request: Update request.

        Returns:
        --------
        None

        :param identifier:
        :param x_org:
        :param mesh_identifier:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateDataProductHostMeshAPIDataDataProductPatchRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            data_product_mesh_availability_request=models.DataProductMeshAvailabilityRequest(
                mesh_identifier=mesh_identifier,
            ),
        )

        req = self._build_request_async(
            method="PATCH",
            path="/api/data/data_product",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.data_product_mesh_availability_request,
                False,
                False,
                "json",
                models.DataProductMeshAvailabilityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_data_product_host_mesh_api_data_data_product_patch",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def query_data_products_data_api_data_data_product_query_post(
        self,
        *,
        x_org: str,
        query: str,
        format_: Optional[models.ConsumeFormat] = None,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Query on data products data.

        Query data product data.

        Args:
        ----
        context: Request context.
        data: Query data.
        browse_filter: Browse filter.
        token: Token data.
        trino: Trino client.


        Returns:
        --------
        StreamingResponse: Result list response.


        Raises:
        -------
        error.InvalidProductQueryError: Product query to many statements error.
        error.ProductQueryNotAllowed: Product query not allowed error.

        :param x_org:
        :param query:
        :param format_:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.QueryDataProductsDataAPIDataDataProductQueryPostRequest(
            format_=format_,
            x_org=x_org,
            x_org_override=x_org_override,
            query_data_product=models.QueryDataProduct(
                query=query,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.query_data_product,
                False,
                False,
                "json",
                models.QueryDataProduct,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="query_data_products_data_api_data_data_product_query_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def query_data_products_data_api_data_data_product_query_post_async(
        self,
        *,
        x_org: str,
        query: str,
        format_: Optional[models.ConsumeFormat] = None,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Query on data products data.

        Query data product data.

        Args:
        ----
        context: Request context.
        data: Query data.
        browse_filter: Browse filter.
        token: Token data.
        trino: Trino client.


        Returns:
        --------
        StreamingResponse: Result list response.


        Raises:
        -------
        error.InvalidProductQueryError: Product query to many statements error.
        error.ProductQueryNotAllowed: Product query not allowed error.

        :param x_org:
        :param query:
        :param format_:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.QueryDataProductsDataAPIDataDataProductQueryPostRequest(
            format_=format_,
            x_org=x_org,
            x_org_override=x_org_override,
            query_data_product=models.QueryDataProduct(
                query=query,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/query",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.query_data_product,
                False,
                False,
                "json",
                models.QueryDataProduct,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="query_data_products_data_api_data_data_product_query_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_expectation_rules_api_data_data_product_expectation_rules_get(
        self,
        *,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExpectationRules:
        r"""Get expectation rules description.

        Get data product expectation rules.

        Args:
        ----
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ExpectationRules: Expectation rules.

        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetExpectationRulesAPIDataDataProductExpectationRulesGetRequest(
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/expectation/rules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_expectation_rules_api_data_data_product_expectation_rules_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ExpectationRules, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_expectation_rules_api_data_data_product_expectation_rules_get_async(
        self,
        *,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExpectationRules:
        r"""Get expectation rules description.

        Get data product expectation rules.

        Args:
        ----
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ExpectationRules: Expectation rules.

        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetExpectationRulesAPIDataDataProductExpectationRulesGetRequest(
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/expectation/rules",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_expectation_rules_api_data_data_product_expectation_rules_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ExpectationRules, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def data_product_share_api_data_data_product_share_post(
        self,
        *,
        identifier: str,
        x_org: str,
        mesh_identifier: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, Any]:
        r"""Update data product available mesh

        :param identifier:
        :param x_org:
        :param mesh_identifier:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DataProductShareAPIDataDataProductSharePostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            data_product_mesh_availability_request=models.DataProductMeshAvailabilityRequest(
                mesh_identifier=mesh_identifier,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/share",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.data_product_mesh_availability_request,
                False,
                False,
                "json",
                models.DataProductMeshAvailabilityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="data_product_share_api_data_data_product_share_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, Any], http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def data_product_share_api_data_data_product_share_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        mesh_identifier: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, Any]:
        r"""Update data product available mesh

        :param identifier:
        :param x_org:
        :param mesh_identifier:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DataProductShareAPIDataDataProductSharePostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            data_product_mesh_availability_request=models.DataProductMeshAvailabilityRequest(
                mesh_identifier=mesh_identifier,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/share",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.data_product_mesh_availability_request,
                False,
                False,
                "json",
                models.DataProductMeshAvailabilityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="data_product_share_api_data_data_product_share_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, Any], http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def data_product_unshare_api_data_data_product_unshare_post(
        self,
        *,
        identifier: str,
        x_org: str,
        mesh_identifier: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, Any]:
        r"""Update data product available mesh

        :param identifier:
        :param x_org:
        :param mesh_identifier:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DataProductUnshareAPIDataDataProductUnsharePostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            data_product_mesh_availability_request=models.DataProductMeshAvailabilityRequest(
                mesh_identifier=mesh_identifier,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/unshare",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.data_product_mesh_availability_request,
                False,
                False,
                "json",
                models.DataProductMeshAvailabilityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="data_product_unshare_api_data_data_product_unshare_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, Any], http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def data_product_unshare_api_data_data_product_unshare_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        mesh_identifier: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Dict[str, Any]:
        r"""Update data product available mesh

        :param identifier:
        :param x_org:
        :param mesh_identifier:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DataProductUnshareAPIDataDataProductUnsharePostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            data_product_mesh_availability_request=models.DataProductMeshAvailabilityRequest(
                mesh_identifier=mesh_identifier,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/unshare",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.data_product_mesh_availability_request,
                False,
                False,
                "json",
                models.DataProductMeshAvailabilityRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="data_product_unshare_api_data_data_product_unshare_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Dict[str, Any], http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_entity_links_api_data_data_product_link_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityLinks:
        r"""Get specific entity 'data_product' links by identifier

        Get data product links.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.common.EntityLinks: Entity links.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityLinksAPIDataDataProductLinkGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/link",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_links_api_data_data_product_link_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityLinks, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_entity_links_api_data_data_product_link_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityLinks:
        r"""Get specific entity 'data_product' links by identifier

        Get data product links.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.common.EntityLinks: Entity links.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityLinksAPIDataDataProductLinkGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/link",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_links_api_data_data_product_link_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityLinks, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_entity_info_api_data_data_product_info_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityInfo:
        r"""Get specific entity 'data_product' info by identifier

        Get data product info.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.common.EntityInfo: Entity info.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityInfoAPIDataDataProductInfoGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/info",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_info_api_data_data_product_info_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityInfo, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_entity_info_api_data_data_product_info_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityInfo:
        r"""Get specific entity 'data_product' info by identifier

        Get data product info.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.common.EntityInfo: Entity info.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityInfoAPIDataDataProductInfoGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/info",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_info_api_data_data_product_info_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityInfo, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_entity_info_api_data_data_product_info_put(
        self,
        *,
        identifier: str,
        x_org: str,
        owner: str,
        contact_ids: List[str],
        links: List[str],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityInfo:
        r"""Update specific entity 'data_product' info by identifier

        Update data product info.

        Args:
        ----
        identifier: Product identifier.
        data: Product info.
        context: Request context
        emitter: Product event emitter.
        token: Token data.

        Returns:
        --------
        schema.common.EntityInfo: Entity info.

        :param identifier:
        :param x_org:
        :param owner:
        :param contact_ids:
        :param links:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateEntityInfoAPIDataDataProductInfoPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            entity_info=models.EntityInfo(
                owner=owner,
                contact_ids=contact_ids,
                links=links,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/info",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.entity_info, False, False, "json", models.EntityInfo
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_entity_info_api_data_data_product_info_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityInfo, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_entity_info_api_data_data_product_info_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        owner: str,
        contact_ids: List[str],
        links: List[str],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.EntityInfo:
        r"""Update specific entity 'data_product' info by identifier

        Update data product info.

        Args:
        ----
        identifier: Product identifier.
        data: Product info.
        context: Request context
        emitter: Product event emitter.
        token: Token data.

        Returns:
        --------
        schema.common.EntityInfo: Entity info.

        :param identifier:
        :param x_org:
        :param owner:
        :param contact_ids:
        :param links:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateEntityInfoAPIDataDataProductInfoPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            entity_info=models.EntityInfo(
                owner=owner,
                contact_ids=contact_ids,
                links=links,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/info",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.entity_info, False, False, "json", models.EntityInfo
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_entity_info_api_data_data_product_info_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.EntityInfo, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_data_product_metadata_api_data_data_product_metadata_v2_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductMetadataResponse:
        r"""Get data_product metadata by identifier

        Get data_product metadata by identifier.

        Args:
        -----
        identifier: DataProduct identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_product.DataProductMetadataResponse: DataProduct metadata response.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductMetadataAPIDataDataProductMetadataV2GetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/metadata/v2",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_metadata_api_data_data_product_metadata_v2_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductMetadataResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_data_product_metadata_api_data_data_product_metadata_v2_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductMetadataResponse:
        r"""Get data_product metadata by identifier

        Get data_product metadata by identifier.

        Args:
        -----
        identifier: DataProduct identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_product.DataProductMetadataResponse: DataProduct metadata response.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductMetadataAPIDataDataProductMetadataV2GetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/metadata/v2",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_metadata_api_data_data_product_metadata_v2_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductMetadataResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_entity_metadata_api_data_data_product_metadata_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DPMetadataViewData:
        r"""Get a consolidated metadata view about a data product

        Get data product metadata.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_quality.DPMetadataViewData: Product metadata.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityMetadataAPIDataDataProductMetadataGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_metadata_api_data_data_product_metadata_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DPMetadataViewData, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_entity_metadata_api_data_data_product_metadata_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DPMetadataViewData:
        r"""Get a consolidated metadata view about a data product

        Get data product metadata.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_quality.DPMetadataViewData: Product metadata.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetEntityMetadataAPIDataDataProductMetadataGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_entity_metadata_api_data_data_product_metadata_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DPMetadataViewData, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_entity_metadata_api_data_data_product_metadata_put(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        fields: OptionalNullable[
            Union[
                Dict[str, models.FieldMetadata],
                Dict[str, models.FieldMetadataTypedDict],
            ]
        ] = UNSET,
        tags: OptionalNullable[List[str]] = UNSET,
        classification_name: OptionalNullable[str] = UNSET,
        sensitivity_names: OptionalNullable[List[str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Update specific entity 'data_product' metadata by identifier (tag/description, field tag/description)

        Update data product metadata.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product metadata.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param fields:
        :param tags:
        :param classification_name: Classification name
        :param sensitivity_names: List of sensitivity names
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateEntityMetadataAPIDataDataProductMetadataPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_entity_metadata_request=models.UpdateEntityMetadataRequest(
                fields=utils.get_pydantic_model(
                    fields, OptionalNullable[Dict[str, models.FieldMetadata]]
                ),
                tags=tags,
                classification_name=classification_name,
                sensitivity_names=sensitivity_names,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_entity_metadata_request,
                False,
                False,
                "json",
                models.UpdateEntityMetadataRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_entity_metadata_api_data_data_product_metadata_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_entity_metadata_api_data_data_product_metadata_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        fields: OptionalNullable[
            Union[
                Dict[str, models.FieldMetadata],
                Dict[str, models.FieldMetadataTypedDict],
            ]
        ] = UNSET,
        tags: OptionalNullable[List[str]] = UNSET,
        classification_name: OptionalNullable[str] = UNSET,
        sensitivity_names: OptionalNullable[List[str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Update specific entity 'data_product' metadata by identifier (tag/description, field tag/description)

        Update data product metadata.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product metadata.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param fields:
        :param tags:
        :param classification_name: Classification name
        :param sensitivity_names: List of sensitivity names
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateEntityMetadataAPIDataDataProductMetadataPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_entity_metadata_request=models.UpdateEntityMetadataRequest(
                fields=utils.get_pydantic_model(
                    fields, OptionalNullable[Dict[str, models.FieldMetadata]]
                ),
                tags=tags,
                classification_name=classification_name,
                sensitivity_names=sensitivity_names,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_entity_metadata_request,
                False,
                False,
                "json",
                models.UpdateEntityMetadataRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_entity_metadata_api_data_data_product_metadata_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def add_entity_metadata_api_data_data_product_metadata_post(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        fields: OptionalNullable[
            Union[
                Dict[str, models.FieldMetadata],
                Dict[str, models.FieldMetadataTypedDict],
            ]
        ] = UNSET,
        tags: OptionalNullable[List[str]] = UNSET,
        classification_name: OptionalNullable[str] = UNSET,
        sensitivity_names: OptionalNullable[List[str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Add data_product metadata by identifier

        Add data_product metadata by identifier (POST endpoint).

        This endpoint adds metadata without replacing existing ones:
        - Classification: Replaces current classification (same as PUT)
        - Sensitivities: Adds to existing sensitivities (different from PUT)
        - Tags: Adds to existing tags (different from PUT)
        - Fields: Adds/updates field metadata (different from PUT)

        Args:
        -----
        identifier: DataProduct identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product metadata add request.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK response.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param fields:
        :param tags:
        :param classification_name: Classification name
        :param sensitivity_names: List of sensitivity names
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddEntityMetadataAPIDataDataProductMetadataPostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_entity_metadata_request=models.UpdateEntityMetadataRequest(
                fields=utils.get_pydantic_model(
                    fields, OptionalNullable[Dict[str, models.FieldMetadata]]
                ),
                tags=tags,
                classification_name=classification_name,
                sensitivity_names=sensitivity_names,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_entity_metadata_request,
                False,
                False,
                "json",
                models.UpdateEntityMetadataRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="add_entity_metadata_api_data_data_product_metadata_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def add_entity_metadata_api_data_data_product_metadata_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        fields: OptionalNullable[
            Union[
                Dict[str, models.FieldMetadata],
                Dict[str, models.FieldMetadataTypedDict],
            ]
        ] = UNSET,
        tags: OptionalNullable[List[str]] = UNSET,
        classification_name: OptionalNullable[str] = UNSET,
        sensitivity_names: OptionalNullable[List[str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Add data_product metadata by identifier

        Add data_product metadata by identifier (POST endpoint).

        This endpoint adds metadata without replacing existing ones:
        - Classification: Replaces current classification (same as PUT)
        - Sensitivities: Adds to existing sensitivities (different from PUT)
        - Tags: Adds to existing tags (different from PUT)
        - Fields: Adds/updates field metadata (different from PUT)

        Args:
        -----
        identifier: DataProduct identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product metadata add request.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK response.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param fields:
        :param tags:
        :param classification_name: Classification name
        :param sensitivity_names: List of sensitivity names
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddEntityMetadataAPIDataDataProductMetadataPostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_entity_metadata_request=models.UpdateEntityMetadataRequest(
                fields=utils.get_pydantic_model(
                    fields, OptionalNullable[Dict[str, models.FieldMetadata]]
                ),
                tags=tags,
                classification_name=classification_name,
                sensitivity_names=sensitivity_names,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_entity_metadata_request,
                False,
                False,
                "json",
                models.UpdateEntityMetadataRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="add_entity_metadata_api_data_data_product_metadata_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def remove_entity_metadata_api_data_data_product_metadata_delete(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        fields: OptionalNullable[
            Union[
                Dict[str, models.FieldMetadata],
                Dict[str, models.FieldMetadataTypedDict],
            ]
        ] = UNSET,
        tags: OptionalNullable[List[str]] = UNSET,
        classification_name: OptionalNullable[str] = UNSET,
        sensitivity_names: OptionalNullable[List[str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Remove specific entity 'data_product' metadata by identifier (tag/description, field tag/description)

        Remove data product metadata.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product metadata.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param fields:
        :param tags:
        :param classification_name: Classification name
        :param sensitivity_names: List of sensitivity names
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RemoveEntityMetadataAPIDataDataProductMetadataDeleteRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            delete_entity_metadata_request=models.DeleteEntityMetadataRequest(
                fields=utils.get_pydantic_model(
                    fields, OptionalNullable[Dict[str, models.FieldMetadata]]
                ),
                tags=tags,
                classification_name=classification_name,
                sensitivity_names=sensitivity_names,
            ),
        )

        req = self._build_request(
            method="DELETE",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_entity_metadata_request,
                False,
                False,
                "json",
                models.DeleteEntityMetadataRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="remove_entity_metadata_api_data_data_product_metadata_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def remove_entity_metadata_api_data_data_product_metadata_delete_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        fields: OptionalNullable[
            Union[
                Dict[str, models.FieldMetadata],
                Dict[str, models.FieldMetadataTypedDict],
            ]
        ] = UNSET,
        tags: OptionalNullable[List[str]] = UNSET,
        classification_name: OptionalNullable[str] = UNSET,
        sensitivity_names: OptionalNullable[List[str]] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Remove specific entity 'data_product' metadata by identifier (tag/description, field tag/description)

        Remove data product metadata.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product metadata.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param fields:
        :param tags:
        :param classification_name: Classification name
        :param sensitivity_names: List of sensitivity names
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RemoveEntityMetadataAPIDataDataProductMetadataDeleteRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            delete_entity_metadata_request=models.DeleteEntityMetadataRequest(
                fields=utils.get_pydantic_model(
                    fields, OptionalNullable[Dict[str, models.FieldMetadata]]
                ),
                tags=tags,
                classification_name=classification_name,
                sensitivity_names=sensitivity_names,
            ),
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/data/data_product/metadata",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.delete_entity_metadata_request,
                False,
                False,
                "json",
                models.DeleteEntityMetadataRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="remove_entity_metadata_api_data_data_product_metadata_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_schema_api_data_data_product_schema_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SchemaOutput:
        r"""Get specific entity 'data_product' schema by identifier

        Get data product schema.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.common.Schema: Product schema.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetSchemaAPIDataDataProductSchemaGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/schema",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_schema_api_data_data_product_schema_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SchemaOutput, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_schema_api_data_data_product_schema_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SchemaOutput:
        r"""Get specific entity 'data_product' schema by identifier

        Get data product schema.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.common.Schema: Product schema.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetSchemaAPIDataDataProductSchemaGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/schema",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_schema_api_data_data_product_schema_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SchemaOutput, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_data_product_schema_api_data_data_product_schema_put(
        self,
        *,
        identifier: str,
        x_org: str,
        details: Union[models.Details, models.DetailsTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SchemaOutput:
        r"""Update specific entity 'data_product' schema by identifier (data product fields)

        Update data product schema.

        Args:
        -----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product data.
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.common.Schema: Product schema.

        :param identifier:
        :param x_org:
        :param details:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateDataProductSchemaAPIDataDataProductSchemaPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_data_product_schema=models.UpdateDataProductSchema(
                details=utils.get_pydantic_model(details, models.Details),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/schema",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_data_product_schema,
                False,
                False,
                "json",
                models.UpdateDataProductSchema,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_data_product_schema_api_data_data_product_schema_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SchemaOutput, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_data_product_schema_api_data_data_product_schema_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        details: Union[models.Details, models.DetailsTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SchemaOutput:
        r"""Update specific entity 'data_product' schema by identifier (data product fields)

        Update data product schema.

        Args:
        -----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Product data.
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.common.Schema: Product schema.

        :param identifier:
        :param x_org:
        :param details:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateDataProductSchemaAPIDataDataProductSchemaPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_data_product_schema=models.UpdateDataProductSchema(
                details=utils.get_pydantic_model(details, models.Details),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/schema",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_data_product_schema,
                False,
                False,
                "json",
                models.UpdateDataProductSchema,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_data_product_schema_api_data_data_product_schema_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.SchemaOutput, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_expectation_results_api_data_data_product_quality_expectation_get(
        self,
        *,
        identifier: str,
        x_org: str,
        last_only: Optional[bool] = True,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExpectationResults:
        r"""Get specific entity 'data_product' expectations by identifier

        Get data product expectation results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        last_only: Last only.
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ExpectationResults: Expectation results.

        :param identifier:
        :param x_org:
        :param last_only:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetExpectationResultsAPIDataDataProductQualityExpectationGetRequest(
                identifier=identifier,
                last_only=last_only,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/quality/expectation",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_expectation_results_api_data_data_product_quality_expectation_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ExpectationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_expectation_results_api_data_data_product_quality_expectation_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        last_only: Optional[bool] = True,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ExpectationResults:
        r"""Get specific entity 'data_product' expectations by identifier

        Get data product expectation results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        last_only: Last only.
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ExpectationResults: Expectation results.

        :param identifier:
        :param x_org:
        :param last_only:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetExpectationResultsAPIDataDataProductQualityExpectationGetRequest(
                identifier=identifier,
                last_only=last_only,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/quality/expectation",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_expectation_results_api_data_data_product_quality_expectation_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ExpectationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_custom_expectation_api_data_data_product_quality_expectation_custom_put(
        self,
        *,
        identifier: str,
        custom_identifier: str,
        x_org: str,
        type_: str,
        kwargs: Dict[str, Any],
        meta: Dict[str, Any],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Update custom expectation for 'data_product' by identifier

        Update custom expectation rule.

        Read description and format of the expectation rules [here](https://greatexpectations.io/expectations/).

        Args:
        ----
        identifier: Product identifier.
        custom_identifier: Custom expectation identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation item.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        :param identifier:
        :param custom_identifier:
        :param x_org:
        :param type:
        :param kwargs:
        :param meta:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateCustomExpectationAPIDataDataProductQualityExpectationCustomPutRequest(
            identifier=identifier,
            custom_identifier=custom_identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_item=models.ExpectationItem(
                type=type_,
                kwargs=kwargs,
                meta=meta,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/quality/expectation/custom",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_item, False, False, "json", models.ExpectationItem
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_custom_expectation_api_data_data_product_quality_expectation_custom_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_custom_expectation_api_data_data_product_quality_expectation_custom_put_async(
        self,
        *,
        identifier: str,
        custom_identifier: str,
        x_org: str,
        type_: str,
        kwargs: Dict[str, Any],
        meta: Dict[str, Any],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Update custom expectation for 'data_product' by identifier

        Update custom expectation rule.

        Read description and format of the expectation rules [here](https://greatexpectations.io/expectations/).

        Args:
        ----
        identifier: Product identifier.
        custom_identifier: Custom expectation identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation item.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        :param identifier:
        :param custom_identifier:
        :param x_org:
        :param type:
        :param kwargs:
        :param meta:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateCustomExpectationAPIDataDataProductQualityExpectationCustomPutRequest(
            identifier=identifier,
            custom_identifier=custom_identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_item=models.ExpectationItem(
                type=type_,
                kwargs=kwargs,
                meta=meta,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/quality/expectation/custom",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_item, False, False, "json", models.ExpectationItem
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_custom_expectation_api_data_data_product_quality_expectation_custom_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def add_custom_expectation_api_data_data_product_quality_expectation_custom_post(
        self,
        *,
        identifier: str,
        x_org: str,
        type_: str,
        kwargs: Dict[str, Any],
        meta: Dict[str, Any],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Add custom expectation for 'data_product' by identifier

        Add custom expectation rule.

        Read description and format of the expectation rules [here](https://greatexpectations.io/expectations/).

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation item.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        :param identifier:
        :param x_org:
        :param type:
        :param kwargs:
        :param meta:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddCustomExpectationAPIDataDataProductQualityExpectationCustomPostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_item=models.ExpectationItem(
                type=type_,
                kwargs=kwargs,
                meta=meta,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/quality/expectation/custom",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_item, False, False, "json", models.ExpectationItem
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="add_custom_expectation_api_data_data_product_quality_expectation_custom_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def add_custom_expectation_api_data_data_product_quality_expectation_custom_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        type_: str,
        kwargs: Dict[str, Any],
        meta: Dict[str, Any],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Add custom expectation for 'data_product' by identifier

        Add custom expectation rule.

        Read description and format of the expectation rules [here](https://greatexpectations.io/expectations/).

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation item.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        :param identifier:
        :param x_org:
        :param type:
        :param kwargs:
        :param meta:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AddCustomExpectationAPIDataDataProductQualityExpectationCustomPostRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_item=models.ExpectationItem(
                type=type_,
                kwargs=kwargs,
                meta=meta,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/quality/expectation/custom",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_item, False, False, "json", models.ExpectationItem
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="add_custom_expectation_api_data_data_product_quality_expectation_custom_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def delete_custom_expectation_api_data_data_product_quality_expectation_custom_delete(
        self,
        *,
        identifier: str,
        custom_identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Delete custom expectation for 'data_product' by identifier

        Delete custom expectation rule.

        Args:
        ----
        identifier: Product identifier.
        custom_identifier: Custom expectation identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param custom_identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteCustomExpectationAPIDataDataProductQualityExpectationCustomDeleteRequest(
            identifier=identifier,
            custom_identifier=custom_identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/data/data_product/quality/expectation/custom",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_custom_expectation_api_data_data_product_quality_expectation_custom_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def delete_custom_expectation_api_data_data_product_quality_expectation_custom_delete_async(
        self,
        *,
        identifier: str,
        custom_identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Delete custom expectation for 'data_product' by identifier

        Delete custom expectation rule.

        Args:
        ----
        identifier: Product identifier.
        custom_identifier: Custom expectation identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param custom_identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteCustomExpectationAPIDataDataProductQualityExpectationCustomDeleteRequest(
            identifier=identifier,
            custom_identifier=custom_identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/data/data_product/quality/expectation/custom",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_custom_expectation_api_data_data_product_quality_expectation_custom_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_expectation_weights_api_data_data_product_quality_expectation_weights_put(
        self,
        *,
        identifier: str,
        x_org: str,
        accuracy: float,
        completeness: float,
        consistency: float,
        uniqueness: float,
        validity: float,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Update specific entity 'data_product' expectation weights

        Update expectation weights.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation weights.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        :param identifier:
        :param x_org:
        :param accuracy:
        :param completeness:
        :param consistency:
        :param uniqueness:
        :param validity:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateExpectationWeightsAPIDataDataProductQualityExpectationWeightsPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_weights=models.ExpectationWeights(
                accuracy=accuracy,
                completeness=completeness,
                consistency=consistency,
                uniqueness=uniqueness,
                validity=validity,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/quality/expectation/weights",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_weights,
                False,
                False,
                "json",
                models.ExpectationWeights,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_expectation_weights_api_data_data_product_quality_expectation_weights_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_expectation_weights_api_data_data_product_quality_expectation_weights_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        accuracy: float,
        completeness: float,
        consistency: float,
        uniqueness: float,
        validity: float,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Update specific entity 'data_product' expectation weights

        Update expectation weights.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation weights.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        :param identifier:
        :param x_org:
        :param accuracy:
        :param completeness:
        :param consistency:
        :param uniqueness:
        :param validity:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateExpectationWeightsAPIDataDataProductQualityExpectationWeightsPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_weights=models.ExpectationWeights(
                accuracy=accuracy,
                completeness=completeness,
                consistency=consistency,
                uniqueness=uniqueness,
                validity=validity,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/quality/expectation/weights",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_weights,
                False,
                False,
                "json",
                models.ExpectationWeights,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_expectation_weights_api_data_data_product_quality_expectation_weights_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_expectation_thresholds_api_data_data_product_quality_expectation_thresholds_put(
        self,
        *,
        identifier: str,
        x_org: str,
        table: float,
        columns: Union[
            Dict[str, models.ExpectationColumnThresholds],
            Dict[str, models.ExpectationColumnThresholdsTypedDict],
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Update specific entity 'data_product' expectation thresholds

        Update expectation thresholds.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation thresholds.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        Raises:
        -------
        error.InvalidQualityParametersError: Invalid quality parameters error.

        :param identifier:
        :param x_org:
        :param table:
        :param columns:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateExpectationThresholdsAPIDataDataProductQualityExpectationThresholdsPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_thresholds=models.ExpectationThresholds(
                table=table,
                columns=utils.get_pydantic_model(
                    columns, Dict[str, models.ExpectationColumnThresholds]
                ),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/quality/expectation/thresholds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_thresholds,
                False,
                False,
                "json",
                models.ExpectationThresholds,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_expectation_thresholds_api_data_data_product_quality_expectation_thresholds_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_expectation_thresholds_api_data_data_product_quality_expectation_thresholds_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        table: float,
        columns: Union[
            Dict[str, models.ExpectationColumnThresholds],
            Dict[str, models.ExpectationColumnThresholdsTypedDict],
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.Expectation:
        r"""Update specific entity 'data_product' expectation thresholds

        Update expectation thresholds.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        data: Expectation thresholds.
        token: Token data.

        Returns:
        --------
        schema.data_quality.Expectation: Expectation.

        Raises:
        -------
        error.InvalidQualityParametersError: Invalid quality parameters error.

        :param identifier:
        :param x_org:
        :param table:
        :param columns:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateExpectationThresholdsAPIDataDataProductQualityExpectationThresholdsPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            expectation_thresholds=models.ExpectationThresholds(
                table=table,
                columns=utils.get_pydantic_model(
                    columns, Dict[str, models.ExpectationColumnThresholds]
                ),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/quality/expectation/thresholds",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.expectation_thresholds,
                False,
                False,
                "json",
                models.ExpectationThresholds,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_expectation_thresholds_api_data_data_product_quality_expectation_thresholds_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.Expectation, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_profiling_results_api_data_data_product_quality_profiling_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProfilingResults:
        r"""Get specific entity 'data_product' quality by identifier

        Get data product profiling results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ProfilingResults: Profiling results.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetProfilingResultsAPIDataDataProductQualityProfilingGetRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/quality/profiling",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_profiling_results_api_data_data_product_quality_profiling_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ProfilingResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_profiling_results_api_data_data_product_quality_profiling_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProfilingResults:
        r"""Get specific entity 'data_product' quality by identifier

        Get data product profiling results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ProfilingResults: Profiling results.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetProfilingResultsAPIDataDataProductQualityProfilingGetRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/quality/profiling",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_profiling_results_api_data_data_product_quality_profiling_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ProfilingResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_validation_results_api_data_data_product_quality_validations_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ValidationResults:
        r"""Get specific entity 'data_product' validations by identifier

        Get data product validation results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ValidationResults: Validation results.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetValidationResultsAPIDataDataProductQualityValidationsGetRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/quality/validations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_validation_results_api_data_data_product_quality_validations_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ValidationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_validation_results_api_data_data_product_quality_validations_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ValidationResults:
        r"""Get specific entity 'data_product' validations by identifier

        Get data product validation results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.data_quality.ValidationResults: Validation results.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetValidationResultsAPIDataDataProductQualityValidationsGetRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/quality/validations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_validation_results_api_data_data_product_quality_validations_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ValidationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_data_product_quality_overview_api_data_data_product_quality_overview_get(
        self,
        *,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductQualityOverview:
        r"""Get data_product quality overview

        Get data product quality overview.

        Args:
        ----
        context: Request context
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.data_quality.ValidationResults: Validation results.

        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductQualityOverviewAPIDataDataProductQualityOverviewGetRequest(
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/quality/overview",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_quality_overview_api_data_data_product_quality_overview_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductQualityOverview, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_data_product_quality_overview_api_data_data_product_quality_overview_get_async(
        self,
        *,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DataProductQualityOverview:
        r"""Get data_product quality overview

        Get data product quality overview.

        Args:
        ----
        context: Request context
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.data_quality.ValidationResults: Validation results.

        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductQualityOverviewAPIDataDataProductQualityOverviewGetRequest(
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/quality/overview",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_quality_overview_api_data_data_product_quality_overview_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DataProductQualityOverview, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_classification_rule_api_data_data_product_classification_rule_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationRule:
        r"""Get specific entity 'data_product' classification rules by identifier

        Get data product classification rule.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationRule: Classification rule.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetClassificationRuleAPIDataDataProductClassificationRuleGetRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/classification/rule",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_classification_rule_api_data_data_product_classification_rule_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationRule, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_classification_rule_api_data_data_product_classification_rule_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationRule:
        r"""Get specific entity 'data_product' classification rules by identifier

        Get data product classification rule.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationRule: Classification rule.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.GetClassificationRuleAPIDataDataProductClassificationRuleGetRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/classification/rule",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_classification_rule_api_data_data_product_classification_rule_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationRule, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_classification_rule_api_data_data_product_classification_rule_put(
        self,
        *,
        identifier: str,
        x_org: str,
        model: str,
        excluded_columns: List[str],
        regex_recognizers: Union[
            List[models.ClassificationRegexRecognizer],
            List[models.ClassificationRegexRecognizerTypedDict],
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationRule:
        r"""Update specific entity 'data_product' classification rules by identifier

        Update data product classification rule.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Classification rule.
        token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationRule: Classification rule.

        :param identifier:
        :param x_org:
        :param model:
        :param excluded_columns:
        :param regex_recognizers:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateClassificationRuleAPIDataDataProductClassificationRulePutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            classification_rule=models.ClassificationRule(
                model=model,
                excluded_columns=excluded_columns,
                regex_recognizers=utils.get_pydantic_model(
                    regex_recognizers, List[models.ClassificationRegexRecognizer]
                ),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/classification/rule",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.classification_rule,
                False,
                False,
                "json",
                models.ClassificationRule,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_classification_rule_api_data_data_product_classification_rule_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationRule, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_classification_rule_api_data_data_product_classification_rule_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        model: str,
        excluded_columns: List[str],
        regex_recognizers: Union[
            List[models.ClassificationRegexRecognizer],
            List[models.ClassificationRegexRecognizerTypedDict],
        ],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationRule:
        r"""Update specific entity 'data_product' classification rules by identifier

        Update data product classification rule.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Classification rule.
        token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationRule: Classification rule.

        :param identifier:
        :param x_org:
        :param model:
        :param excluded_columns:
        :param regex_recognizers:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateClassificationRuleAPIDataDataProductClassificationRulePutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            classification_rule=models.ClassificationRule(
                model=model,
                excluded_columns=excluded_columns,
                regex_recognizers=utils.get_pydantic_model(
                    regex_recognizers, List[models.ClassificationRegexRecognizer]
                ),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/classification/rule",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.classification_rule,
                False,
                False,
                "json",
                models.ClassificationRule,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_classification_rule_api_data_data_product_classification_rule_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationRule, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_classification_result_api_data_data_product_classification_result_get(
        self,
        *,
        identifier: str,
        x_org: str,
        resolved: OptionalNullable[bool] = UNSET,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationResults:
        r"""Get specific entity 'data_product' classification results by identifier

        Get data product classification results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        resolved: Resolved.
        _token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationResults: Classification results.

        :param identifier:
        :param x_org:
        :param resolved:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetClassificationResultAPIDataDataProductClassificationResultGetRequest(
            identifier=identifier,
            resolved=resolved,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/classification/result",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_classification_result_api_data_data_product_classification_result_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_classification_result_api_data_data_product_classification_result_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        resolved: OptionalNullable[bool] = UNSET,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationResults:
        r"""Get specific entity 'data_product' classification results by identifier

        Get data product classification results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        resolved: Resolved.
        _token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationResults: Classification results.

        :param identifier:
        :param x_org:
        :param resolved:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetClassificationResultAPIDataDataProductClassificationResultGetRequest(
            identifier=identifier,
            resolved=resolved,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/classification/result",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_classification_result_api_data_data_product_classification_result_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_classification_result_api_data_data_product_classification_result_put(
        self,
        *,
        identifier: str,
        x_org: str,
        resolve: List[str],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationResults:
        r"""Update specific entity 'data_product' classification results by identifier

        Update data product classification results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Classification result.
        token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationResults: Classification results.

        :param identifier:
        :param x_org:
        :param resolve:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateClassificationResultAPIDataDataProductClassificationResultPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_classification_result=models.UpdateClassificationResult(
                resolve=resolve,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/classification/result",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_classification_result,
                False,
                False,
                "json",
                models.UpdateClassificationResult,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_classification_result_api_data_data_product_classification_result_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_classification_result_api_data_data_product_classification_result_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        resolve: List[str],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ClassificationResults:
        r"""Update specific entity 'data_product' classification results by identifier

        Update data product classification results.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Classification result.
        token: Token data.

        Returns:
        --------
        schema.data_product.ClassificationResults: Classification results.

        :param identifier:
        :param x_org:
        :param resolve:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateClassificationResultAPIDataDataProductClassificationResultPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            update_classification_result=models.UpdateClassificationResult(
                resolve=resolve,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/classification/result",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_classification_result,
                False,
                False,
                "json",
                models.UpdateClassificationResult,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_classification_result_api_data_data_product_classification_result_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ClassificationResults, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_data_product_data_api_data_data_product_data_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResultListResponse:
        r"""Data preview

        Get data product data.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.common.ResultListResponse: Result list response.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductDataAPIDataDataProductDataGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_data_api_data_data_product_data_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ResultListResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_data_product_data_api_data_data_product_data_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ResultListResponse:
        r"""Data preview

        Get data product data.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        trino: Trino client.
        _token: Token data.

        Returns:
        --------
        schema.common.ResultListResponse: Result list response.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetDataProductDataAPIDataDataProductDataGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_data_product_data_api_data_data_product_data_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ResultListResponse, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def delete_data_api_data_data_product_data_delete(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Delete stored data.

        Delete data product data.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteDataAPIDataDataProductDataDeleteRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/data/data_product/data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_data_api_data_data_product_data_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def delete_data_api_data_data_product_data_delete_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Delete stored data.

        Delete data product data.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        trino: Trino client.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteDataAPIDataDataProductDataDeleteRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/data/data_product/data",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_data_api_data_data_product_data_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_compute_file_api_data_data_product_compute_file_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""get compute file

        Get data product compute file.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        str: compute file content.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeFileAPIDataDataProductComputeFileGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/compute/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_file_api_data_data_product_compute_file_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_compute_file_api_data_data_product_compute_file_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> str:
        r"""get compute file

        Get data product compute file.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        str: compute file content.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeFileAPIDataDataProductComputeFileGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/compute/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_file_api_data_data_product_compute_file_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(str, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_compute_file_api_data_data_product_compute_file_put(
        self,
        *,
        identifier: str,
        x_org: str,
        compute_file: Union[models.ComputeFile, models.ComputeFileTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Add/Replace compute file (assign/reassign)

        Upload a custom compute file.

        Limited access endpoint for developers/engineers.

        Custom support allowed for devs to PoC things, these products can not be scheduled.

        Args:
        ----
        identifier: Product identifier.
        compute_file: Compute file.
        context: Request context
        emitter: Product event emitter.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param compute_file:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComputeFileAPIDataDataProductComputeFilePutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            body_update_compute_file_api_data_data_product_compute_file_put=models.BodyUpdateComputeFileAPIDataDataProductComputeFilePut(
                compute_file=utils.get_pydantic_model(compute_file, models.ComputeFile),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/compute/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body_update_compute_file_api_data_data_product_compute_file_put,
                False,
                False,
                "multipart",
                models.BodyUpdateComputeFileAPIDataDataProductComputeFilePut,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_compute_file_api_data_data_product_compute_file_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_compute_file_api_data_data_product_compute_file_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        compute_file: Union[models.ComputeFile, models.ComputeFileTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Add/Replace compute file (assign/reassign)

        Upload a custom compute file.

        Limited access endpoint for developers/engineers.

        Custom support allowed for devs to PoC things, these products can not be scheduled.

        Args:
        ----
        identifier: Product identifier.
        compute_file: Compute file.
        context: Request context
        emitter: Product event emitter.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param compute_file:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComputeFileAPIDataDataProductComputeFilePutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            body_update_compute_file_api_data_data_product_compute_file_put=models.BodyUpdateComputeFileAPIDataDataProductComputeFilePut(
                compute_file=utils.get_pydantic_model(compute_file, models.ComputeFile),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/compute/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.body_update_compute_file_api_data_data_product_compute_file_put,
                False,
                False,
                "multipart",
                models.BodyUpdateComputeFileAPIDataDataProductComputeFilePut,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_compute_file_api_data_data_product_compute_file_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def delete_compute_file_api_data_data_product_compute_file_delete(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Delete compute file

        Delete data product compute file.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        None

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteComputeFileAPIDataDataProductComputeFileDeleteRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="DELETE",
            path="/api/data/data_product/compute/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_compute_file_api_data_data_product_compute_file_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def delete_compute_file_api_data_data_product_compute_file_delete_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        r"""Delete compute file

        Delete data product compute file.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        None

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.DeleteComputeFileAPIDataDataProductComputeFileDeleteRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/api/data/data_product/compute/file",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="delete_compute_file_api_data_data_product_compute_file_delete",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_compute_builder_api_data_data_product_compute_builder_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BuilderPipelineOutput:
        r"""Get builder pipeline

        Get data product compute builder.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        BuilderPipeline: Builder pipeline.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeBuilderAPIDataDataProductComputeBuilderGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/compute/builder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_builder_api_data_data_product_compute_builder_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BuilderPipelineOutput, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_compute_builder_api_data_data_product_compute_builder_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BuilderPipelineOutput:
        r"""Get builder pipeline

        Get data product compute builder.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        BuilderPipeline: Builder pipeline.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeBuilderAPIDataDataProductComputeBuilderGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/compute/builder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_builder_api_data_data_product_compute_builder_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BuilderPipelineOutput, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_compute_builder_api_data_data_product_compute_builder_put(
        self,
        *,
        identifier: str,
        x_org: str,
        config: Union[models.OptionalSparkConfig, models.OptionalSparkConfigTypedDict],
        inputs: Union[
            models.BuilderPipelineInputInputs,
            models.BuilderPipelineInputInputsTypedDict,
        ],
        transformations: Union[
            List[models.BuilderPipelineInputTransformation],
            List[models.BuilderPipelineInputTransformationTypedDict],
        ],
        finalisers: Union[models.FinalisersInput, models.FinalisersInputTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        preview: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Add/Replace builder pipeline

        Update data product compute builder.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        unit_emitter: Resource event emitter.
        data: Builder pipeline.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductInvalidBuilderError: Product invalid builder error.

        :param identifier:
        :param x_org:
        :param config: OptionalSparkConfig model.
        :param inputs:
        :param transformations:
        :param finalisers: Finalisers model.
        :param x_org_override:
        :param preview:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComputeBuilderAPIDataDataProductComputeBuilderPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            builder_pipeline_input=models.BuilderPipelineInput(
                config=utils.get_pydantic_model(config, models.OptionalSparkConfig),
                inputs=utils.get_pydantic_model(
                    inputs, models.BuilderPipelineInputInputs
                ),
                transformations=utils.get_pydantic_model(
                    transformations, List[models.BuilderPipelineInputTransformation]
                ),
                finalisers=utils.get_pydantic_model(finalisers, models.FinalisersInput),
                preview=preview,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/compute/builder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.builder_pipeline_input,
                False,
                False,
                "json",
                models.BuilderPipelineInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_compute_builder_api_data_data_product_compute_builder_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_compute_builder_api_data_data_product_compute_builder_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        config: Union[models.OptionalSparkConfig, models.OptionalSparkConfigTypedDict],
        inputs: Union[
            models.BuilderPipelineInputInputs,
            models.BuilderPipelineInputInputsTypedDict,
        ],
        transformations: Union[
            List[models.BuilderPipelineInputTransformation],
            List[models.BuilderPipelineInputTransformationTypedDict],
        ],
        finalisers: Union[models.FinalisersInput, models.FinalisersInputTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        preview: Optional[bool] = False,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Add/Replace builder pipeline

        Update data product compute builder.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        unit_emitter: Resource event emitter.
        data: Builder pipeline.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductInvalidBuilderError: Product invalid builder error.

        :param identifier:
        :param x_org:
        :param config: OptionalSparkConfig model.
        :param inputs:
        :param transformations:
        :param finalisers: Finalisers model.
        :param x_org_override:
        :param preview:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComputeBuilderAPIDataDataProductComputeBuilderPutRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
            builder_pipeline_input=models.BuilderPipelineInput(
                config=utils.get_pydantic_model(config, models.OptionalSparkConfig),
                inputs=utils.get_pydantic_model(
                    inputs, models.BuilderPipelineInputInputs
                ),
                transformations=utils.get_pydantic_model(
                    transformations, List[models.BuilderPipelineInputTransformation]
                ),
                finalisers=utils.get_pydantic_model(finalisers, models.FinalisersInput),
                preview=preview,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/compute/builder",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.builder_pipeline_input,
                False,
                False,
                "json",
                models.BuilderPipelineInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_compute_builder_api_data_data_product_compute_builder_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def run_compute_builder_api_data_data_product_compute_builder_run_post(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Run builder pipeline

        Update data product compute builder.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        unit_emitter: Resource event emitter.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductMissingBuilderError: Product missing builder.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.RunComputeBuilderAPIDataDataProductComputeBuilderRunPostRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/compute/builder/run",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="run_compute_builder_api_data_data_product_compute_builder_run_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def run_compute_builder_api_data_data_product_compute_builder_run_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Run builder pipeline

        Update data product compute builder.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        unit_emitter: Resource event emitter.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductMissingBuilderError: Product missing builder.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.RunComputeBuilderAPIDataDataProductComputeBuilderRunPostRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
            )
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/compute/builder/run",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="run_compute_builder_api_data_data_product_compute_builder_run_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def run_quality_api_data_data_product_compute_builder_run_quality_post(
        self,
        *,
        identifier: str,
        x_org: str,
        config: Union[models.OptionalSparkConfig, models.OptionalSparkConfigTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Run data quality

        Run data quality job for a data product.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        data: Config for a job.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductMissingTableError: Product not having a table.

        :param identifier:
        :param x_org:
        :param config: OptionalSparkConfig model.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.RunQualityAPIDataDataProductComputeBuilderRunQualityPostRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
                existing_product_job=models.ExistingProductJob(
                    config=utils.get_pydantic_model(config, models.OptionalSparkConfig),
                ),
            )
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/compute/builder/run/quality",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.existing_product_job,
                False,
                False,
                "json",
                models.ExistingProductJob,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="run_quality_api_data_data_product_compute_builder_run_quality_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def run_quality_api_data_data_product_compute_builder_run_quality_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        config: Union[models.OptionalSparkConfig, models.OptionalSparkConfigTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Run data quality

        Run data quality job for a data product.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        data: Config for a job.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductMissingTableError: Product not having a table.

        :param identifier:
        :param x_org:
        :param config: OptionalSparkConfig model.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.RunQualityAPIDataDataProductComputeBuilderRunQualityPostRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
                existing_product_job=models.ExistingProductJob(
                    config=utils.get_pydantic_model(config, models.OptionalSparkConfig),
                ),
            )
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/compute/builder/run/quality",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.existing_product_job,
                False,
                False,
                "json",
                models.ExistingProductJob,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="run_quality_api_data_data_product_compute_builder_run_quality_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def run_profiling_api_data_data_product_compute_builder_run_profiling_post(
        self,
        *,
        identifier: str,
        x_org: str,
        config: Union[models.OptionalSparkConfig, models.OptionalSparkConfigTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Run data profiling

        Run data profiling job for a data product.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        data: Config for a job.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductMissingTableError: Product not having a table.

        :param identifier:
        :param x_org:
        :param config: OptionalSparkConfig model.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.RunProfilingAPIDataDataProductComputeBuilderRunProfilingPostRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
                existing_product_job=models.ExistingProductJob(
                    config=utils.get_pydantic_model(config, models.OptionalSparkConfig),
                ),
            )
        )

        req = self._build_request(
            method="POST",
            path="/api/data/data_product/compute/builder/run/profiling",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.existing_product_job,
                False,
                False,
                "json",
                models.ExistingProductJob,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="run_profiling_api_data_data_product_compute_builder_run_profiling_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def run_profiling_api_data_data_product_compute_builder_run_profiling_post_async(
        self,
        *,
        identifier: str,
        x_org: str,
        config: Union[models.OptionalSparkConfig, models.OptionalSparkConfigTypedDict],
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Run data profiling

        Run data profiling job for a data product.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        data: Config for a job.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        Raises:
        -------
        error.ProductMissingTableError: Product not having a table.

        :param identifier:
        :param x_org:
        :param config: OptionalSparkConfig model.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = (
            models.RunProfilingAPIDataDataProductComputeBuilderRunProfilingPostRequest(
                identifier=identifier,
                x_org=x_org,
                x_org_override=x_org_override,
                existing_product_job=models.ExistingProductJob(
                    config=utils.get_pydantic_model(config, models.OptionalSparkConfig),
                ),
            )
        )

        req = self._build_request_async(
            method="POST",
            path="/api/data/data_product/compute/builder/run/profiling",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.existing_product_job,
                False,
                False,
                "json",
                models.ExistingProductJob,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="run_profiling_api_data_data_product_compute_builder_run_profiling_post",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_compute_builder_state_api_data_data_product_compute_builder_state_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BuilderPipelineState:
        r"""Get builder pipeline state

        Get data product compute builder state.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        BuilderPipelineState: Builder pipeline state.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeBuilderStateAPIDataDataProductComputeBuilderStateGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/compute/builder/state",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_builder_state_api_data_data_product_compute_builder_state_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BuilderPipelineState, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_compute_builder_state_api_data_data_product_compute_builder_state_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BuilderPipelineState:
        r"""Get builder pipeline state

        Get data product compute builder state.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.

        Returns:
        --------
        BuilderPipelineState: Builder pipeline state.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeBuilderStateAPIDataDataProductComputeBuilderStateGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/compute/builder/state",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_builder_state_api_data_data_product_compute_builder_state_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BuilderPipelineState, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def update_compute_state_api_data_data_product_compute_state_put(
        self,
        *,
        identifier: str,
        x_org: str,
        state: Union[models.State, models.StateTypedDict],
        job_type: OptionalNullable[models.ComputeJobType] = UNSET,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Update compute state (unassign, schedule, reschedule, unschedule)

        Update data product compute state.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Compute state.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param state:
        :param job_type: Compute job suffix.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComputeStateAPIDataDataProductComputeStatePutRequest(
            identifier=identifier,
            job_type=job_type,
            x_org=x_org,
            x_org_override=x_org_override,
            update_compute_state=models.UpdateComputeState(
                state=utils.get_pydantic_model(state, models.State),
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/api/data/data_product/compute/state",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_compute_state,
                False,
                False,
                "json",
                models.UpdateComputeState,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_compute_state_api_data_data_product_compute_state_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def update_compute_state_api_data_data_product_compute_state_put_async(
        self,
        *,
        identifier: str,
        x_org: str,
        state: Union[models.State, models.StateTypedDict],
        job_type: OptionalNullable[models.ComputeJobType] = UNSET,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.BackendDataSchemaCommonOK:
        r"""Update compute state (unassign, schedule, reschedule, unschedule)

        Update data product compute state.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        emitter: Product event emitter.
        data: Compute state.
        token: Token data.

        Returns:
        --------
        schema.common.OK: OK.

        :param identifier:
        :param x_org:
        :param state:
        :param job_type: Compute job suffix.
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.UpdateComputeStateAPIDataDataProductComputeStatePutRequest(
            identifier=identifier,
            job_type=job_type,
            x_org=x_org,
            x_org_override=x_org_override,
            update_compute_state=models.UpdateComputeState(
                state=utils.get_pydantic_model(state, models.State),
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/api/data/data_product/compute/state",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.update_compute_state,
                False,
                False,
                "json",
                models.UpdateComputeState,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="update_compute_state_api_data_data_product_compute_state_put",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.BackendDataSchemaCommonOK, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_compute_lineage_api_data_data_product_compute_lineage_get(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DPComputeLineage:
        r"""Get a lineage of a compute transformations.

        Get data product compute lineage.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.
        detailed: Detailed.

        Returns:
        --------
        schema.data_quality.DPComputeLineage: Compute lineage.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeLineageAPIDataDataProductComputeLineageGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/compute/lineage",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_lineage_api_data_data_product_compute_lineage_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DPComputeLineage, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_compute_lineage_api_data_data_product_compute_lineage_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DPComputeLineage:
        r"""Get a lineage of a compute transformations.

        Get data product compute lineage.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.
        detailed: Detailed.

        Returns:
        --------
        schema.data_quality.DPComputeLineage: Compute lineage.

        :param identifier:
        :param x_org:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetComputeLineageAPIDataDataProductComputeLineageGetRequest(
            identifier=identifier,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/compute/lineage",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_compute_lineage_api_data_data_product_compute_lineage_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DPComputeLineage, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    def get_lineage_data_product_api_data_data_product_lineage_get(
        self,
        *,
        identifier: str,
        x_org: str,
        show_jobs: Optional[bool] = True,
        depth: Optional[int] = 20,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DPLineage:
        r"""Get a lineage of a data product.

        Get data product lineage.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.
        show_jobs: Show jobs.
        depth: Depth.

        Returns:
        --------
        schema.data_quality.DPLineage: Lineage.

        :param identifier:
        :param x_org:
        :param show_jobs:
        :param depth:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetLineageDataProductAPIDataDataProductLineageGetRequest(
            identifier=identifier,
            show_jobs=show_jobs,
            depth=depth,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request(
            method="GET",
            path="/api/data/data_product/lineage",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_lineage_data_product_api_data_data_product_lineage_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DPLineage, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)

    async def get_lineage_data_product_api_data_data_product_lineage_get_async(
        self,
        *,
        identifier: str,
        x_org: str,
        show_jobs: Optional[bool] = True,
        depth: Optional[int] = 20,
        x_org_override: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DPLineage:
        r"""Get a lineage of a data product.

        Get data product lineage.

        Args:
        ----
        identifier: Product identifier.
        context: Request context
        _token: Token data.
        show_jobs: Show jobs.
        depth: Depth.

        Returns:
        --------
        schema.data_quality.DPLineage: Lineage.

        :param identifier:
        :param x_org:
        :param show_jobs:
        :param depth:
        :param x_org_override:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GetLineageDataProductAPIDataDataProductLineageGetRequest(
            identifier=identifier,
            show_jobs=show_jobs,
            depth=depth,
            x_org=x_org,
            x_org_override=x_org_override,
        )

        req = self._build_request_async(
            method="GET",
            path="/api/data/data_product/lineage",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="get_lineage_data_product_api_data_data_product_lineage_get",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["422", "4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DPLineage, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                errors.HTTPValidationErrorData, http_res
            )
            raise errors.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.ToanFndtnDefaultError(
                "API error occurred", http_res, http_res_text
            )

        raise errors.ToanFndtnDefaultError("Unexpected response received", http_res)
